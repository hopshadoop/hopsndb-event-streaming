//============================================================================
// Name        : HopsJNIDispatcher.cpp
// Created on  : Feb 2, 2015
// Author      : sri(skug@kth.se)
// Version     : 1.0
// Copyright   : SICS
// Description : Dispatcher thread is processing and dispatching the objects to java
//============================================================================

#include "../include/HopsJNIDispatcher.h"

#include <jni_md.h>
#include <stdlib.h>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <map>
#include <string>
#include <utility>
#include <algorithm>

#define EVENT_API_CONFIG "EventAPIConfig.ini"

#define SECONDS      1000000000
#define MILLISECONDS 1000000
#define MICROSECONDS 1000
#define NANOSECONDS  1

using namespace hops::utl;
using namespace cnf;

ofstream m_ofStream;
int globalTransCounter = 0;
HopsJNIDispatcher::HopsJNIDispatcher() {
  m_ptrJavaObjectDispatcherQ = NULL;
  m_jvm = NULL;
  m_newCallBackObj = NULL;
  m_ptrNeighbourDispatcher = NULL;
  m_mdMultiThreadCallBackMethod = NULL;
  m_mdSingleThreadCallBackMethod = NULL;
  m_mdBuildCompositeMethod = NULL;
  m_ptrThreadToken = NULL;
  m_ptrJNI = NULL;
  m_ptrCondtionLock = NULL;
  m_ptrHopsObjects = NULL;
  m_ptrSleepTimer = NULL;
  m_jniClassGlobalRef = NULL;

  m_bIsIinterrupt = false;
  m_bIsThisFirstTime = false;
  m_bIsPrintEnabled = false;
  m_isSingleThread = false;
  m_bIsReferenceTableProvided = false;

  m_iTotalNumberOfClasses=0;
  m_iTablePositionOffset = 0;
  m_iSingleContainerSize = 0;
  m_ullPreviousDispatchTime = 0;
  m_iInternalGCIIndex = 0;
  m_threadid = 0;
  m_ofStream.open("/home/sri/dump.txt");
  m_ofStream << "##GCI,Number of transaction, distpatch time" << endl;

}

HopsJNIDispatcher::~HopsJNIDispatcher() {
  std::cout << "[HopsJNIDispatcher] Deallocating the memory now "
	    << std::endl;
  delete m_ptrSleepTimer;
}
void HopsJNIDispatcher::InintJNIDispatcher(
					   HopsEventQueueFrame *_ptrJavaObjectDispatcher, JavaVM *_ptrJVM,
					   QueueSizeCondition *_ptrCondtionLock, int _iThreadSingleContainerSize) {

  m_ptrJavaObjectDispatcherQ = _ptrJavaObjectDispatcher;
  m_jvm = _ptrJVM;
  m_iSingleContainerSize = _iThreadSingleContainerSize;
  m_ptrSleepTimer = new HopsEventStreamingTimer(1, false);
  m_ptrCondtionLock = _ptrCondtionLock;

}
void *HopsJNIDispatcher::Run(void * _pLHandler) {
  ((HopsJNIDispatcher*) _pLHandler)->StartProcesser();
  return NULL;
}

pthread_t HopsJNIDispatcher::StartEventProcessor(
						 HopsJNIDispatcher *_ptrHopsJNIDispatcher,
						 HopsJNIDispatcher *_ptrFriendDispatcher, ThreadToken *_ptrThreadToken) {

  m_ptrThreadToken = _ptrThreadToken;
  pthread_create(&m_threadid, NULL, (void*(*)(void*)) HopsJNIDispatcher::Run, (void*) _ptrHopsJNIDispatcher);
  printf(
	 "[HopsJNIDispatcher][INFO] ############  Event processor thread id -  %li \n",
	 m_threadid);

  m_ptrNeighbourDispatcher = _ptrFriendDispatcher;
  return m_threadid;
}

void HopsJNIDispatcher::InitializeTablePosition(std::string _sTableName) {
  m_TablePositions.insert(
			  std::make_pair<std::string, int>(_sTableName,
							   m_iTablePositionOffset));
  ++m_iTablePositionOffset;
}

void HopsJNIDispatcher::PrintJNIPlainMessage(int _iCategory,
					     const char *_pzMessage) {
  char l_zTemp[400];
  memset(l_zTemp, 0, sizeof(l_zTemp));
  const char *l_ptrTrailer = "\033[0m\n";
  switch (_iCategory) {
  case 0: // info
    {

      sprintf(l_zTemp,
	      "\033[22;33m\a [HopsLoadSimulationJNIDispatcher][INFO] ### %s ",
	      _pzMessage);

    }
    break;
  case 1: // warning
    {
      sprintf(l_zTemp,
	      "\033[22;33m\a [HopsLoadSimulationJNIDispatcher][WARNING] ### %s ",
	      _pzMessage);

    }
    break;
  case 2: // error
    {

      sprintf(l_zTemp,
	      "\033[22;33m\a [HopsLoadSimulationJNIDispatcher][ERROR] ### %s ",
	      _pzMessage);
    }
    break;

  }
  sprintf(l_zTemp + (int) strlen(l_zTemp), " %s ", l_ptrTrailer);
  printf("%s", l_zTemp);
  if (m_ptrJNI->ExceptionCheck()) {
    m_ptrJNI->ExceptionDescribe();
    m_ptrJNI->ExceptionClear();
  }
  exit(EXIT_FAILURE);

}
void HopsJNIDispatcher::WarmUpJavaObjectConfiguration() {
  HopsConfigFile cFile(EVENT_API_CONFIG);
  char l_zConfigReaderArray[1024];
  char l_zValues[1024];
  memset(l_zValues, 0, size"JAVA_CLASS_NAME_%d", m + 1);
  //TODO Sometime class length is bigger than this limit, we should change to dynamic memory allocation
  char l_zSetOfSignatures[2048];
  strcpy(l_zSetOfSignatures, cFile.GetValue(l_zBuff));

  HopsStringTokenizer l_oClassSigSep(l_zSetOfSignatures, '|');
  const char *l_pzNewBuildFunctionName = l_oClassSigSep.GetTokenAt(0);

  std::map<const char*, const char*> mapDbColNameToJavaFunctions;
  std::map<const char *, const char *> mapDbColNameToSignatures;
  m_ptrHopsObjects[m] = new HopObject(m_ptrJNI);
  m_ptrHopsObjects[m]->SetCallBackClassAndObject(m_jniClassGlobalRef,
						 m_newCallBackObj);
  for (int j = 1; j < l_oClassSigSep.GetCount(); ++j) {
    HopsStringTokenizer l_oInterCol(l_oClassSigSep.GetTokenAt(j), ',');
    mapDbColNameToJavaFunctions.insert(
				       std::make_pair<const char *, const char *>(
										  l_oInterCol.GetTokenAt(0),
										  l_oInterCol.GetTokenAt(1)));
    mapDbColNameToSignatures.insert(
				    std::make_pair<const char *, const char *>(
									       l_oInterCol.GetTokenAt(0),
									       l_oInterCol.GetTokenAt(2)));
  }
  m_ptrHopsObjects[m]->PrepareHopJavaObjects(l_pzNewBuildFunctionName,
					     mapDbColNameToJavaFunctions, mapDbColNameToSignatures);

}

memset(l_zConfigReaderArray, 0, sizeof(l_zConfigReaderArray));
memset(l_zValues, 0, sizeof(l_zValues));

sprintf(l_zConfigReaderArray, "MULTI_THREAD_CLASS_BUILDER_NAME");
strcpy(l_zValues, cFile.GetValue(l_zConfigReaderArray));

HopsStringTokenizer l_oListSepMTBuildCallBack(l_zValues, '|');

memset(m_zMultiThreadBuildCallBackMethod, 0,
       sizeof(m_zMultiThreadBuildCallBackMethod));
memset(m_zMultiThreadBuildClassBackMethodSig, 0,
       sizeof(m_zMultiThreadBuildClassBackMethodSig));

strcpy(m_zMultiThreadBuildCallBackMethod,
       l_oListSepMTBuildCallBack.GetTokenAt(0));
strcpy(m_zMultiThreadBuildClassBackMethodSig,
       l_oListSepMTBuildCallBack.GetTokenAt(1));

memset(l_zConfigReaderArray, 0, sizeof(l_zConfigReaderArray));

sprintf(l_zConfigReaderArray, "MULTI_THREAD_CALLBACK_METHOD");
strcpy(l_zValues, cFile.GetValue(l_zConfigReaderArray));

HopsStringTokenizer l_oListSepMTCallBack(l_zValues, '|'); // this separator helps to extract the load deviation

memset(m_zMultiThreadCallBackMethodName, 0,
       sizeof(m_zMultiThreadCallBackMethodName));
memset(m_zMultiThreadCallBackMethodSig, 0,
       sizeof(m_zMultiThreadCallBackMethodSig));

strcpy(m_zMultiThreadCallBackMethodName,
       l_oListSepMTCallBack.GetTokenAt(0));
strcpy(m_zMultiThreadCallBackMethodSig, l_oListSepMTCallBack.GetTokenAt(1));

m_mdMultiThreadCallBackMethod = m_ptrJNI->GetMethodID(m_jniClassGlobalRef,
						      m_zMultiThreadCallBackMethodName, m_zMultiThreadCallBackMethodSig);

if (m_mdMultiThreadCallBackMethod == NULL) {
  PrintJNIPlainMessage(2,
		       "Exception occurred in finding multi-threaded callback method");
 }
m_mdBuildCompositeMethod = m_ptrJNI->GetMethodID(m_jniClassGlobalRef,
						 m_zMultiThreadBuildCallBackMethod,
						 m_zMultiThreadBuildClassBackMethodSig);

if (m_mdBuildCompositeMethod == NULL) {
  PrintJNIPlainMessage(2,
		       "Exception occurred in finding in build composite Java method ");
 }
m_mdSingleThreadCallBackMethod = m_ptrJNI->GetMethodID(m_jniClassGlobalRef,
						       m_zSingleThreadCallBackMethod, m_zSingleThreadCallBackMethodSig);

m_mdResetMethod = m_ptrJNI->GetMethodID(m_jniClassGlobalRef,
					m_zResetMethod, m_zResetMethodSig);

if (m_mdSingleThreadCallBackMethod == NULL) {
  PrintJNIPlainMessage(2,
		       "Exception occurred in finding Single thread java method");
 }
if (m_mdResetMethod == NULL) {
  PrintJNIPlainMessage(2,
		       "Exception occurred in finding reset java method");
 }
if (m_bIsPrintEnabled) {
  printf(
	 "[HopsJNIDispatcher][INFO] ########### builder class method    : %s\n",
	 m_zMultiThreadBuildCallBackMethod);
  printf(
	 "[HopsJNIDispatcher][INFO] ########### builder class method sig : %s\n",
	 m_zMultiThreadBuildClassBackMethodSig);
  printf(
	 "[HopsJNIDispatcher][INFO] ########### Callback method    : %s\n",
	 m_zMultiThreadCallBackMethodName);
  printf(
	 "[HopsJNIDispatcher][INFO] ########### Catcd to cleanup unwanted memory , because , there is not reference table
int HopsJNIDispatcher::SingleThreadDispatchWithoutReferenceTable() {

int GlobalTotalTransactionCount = 0;

m_mapOfReturnObjectItr = m_mapOfReturnObject.begin();
for (; m_mapOfReturnObjectItr != m_mapOfReturngEvent->second.begin(),m_itrPendingEvent->second.end());
for (int i = 0; i < (int) m_itrPendingEvent->second.size(); ++i) {
// go through all the pending event and dispatch , this will avoid unnecessary dispatch
int l_iPendingEventId = m_itrPendingEvent->second[i];
// now lets search the pending event id in the main map,

l_innermapItr = m_mapOfBTObjectsItr->second.find(
l_iPendingEventId);
if (l_innermapItr != m_mapOfBTObjectsItr->second.end()) {
++GlobalTotalTransactionCount;
int l_iPendingEventId = l_innermapItr->first;
for (int j = 0; j < (int) vecLisObjectItr->second.clear();
}

return GlobalTotalTransactionCount;

}
int HopsJNIDispatcher::Prepqq